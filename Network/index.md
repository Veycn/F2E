
### HTTP1 存在的问题
#### HTTP1 - 队头堵塞

浏览器向服务器请求文件。假设请求A、B两个文件。如果两个文件差不多大，那发送顺序大概是这样的：

```typescript
AAABBB
```

如果A比B大的多，就会是这个样子：
```typescript
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAABB
```

A 需要很久的时间才发送完，B的发送就一直被挡在A后面，这就是 `队头堵塞`。


解决方案是将文件分成很小的「块」，在网络链路上分块发送这些「块」。大概是这样：

```typescript
ABABAAAAAAAAAAAAAAAAAAAAAAAAAAA
```

这样队列中比较小的文件就能更快地到达。但是这种方式在 HTTP1 中无法实现。

#### TCP 连接数限制


以 `Chrome` 来说，同一域名下同时最多发起 6 个 `TCP` 请求。一个页面往往有好几十个资源，又由于队头堵塞的问题存在，为了防止资源过慢地加载，使用 `域名分片` 将资源放在不同的域名下。

不同域名发起请求，以一种比较巧妙的方式避开了请求数量的限制。

打开过多的`TCP`连接也是有很大消耗的，比如服务器和内存的压力，需要维持 `TCP` 连接，计算`TLS`等。


#### HTTP2 - 帧

浏览器打开许多并行`TCP`连接，这既不高效，也不可扩展。

在 `HTTP2` 中，在每个资源块前面增加一个`数据帧`，数据帧描述了这个资源块属于哪一个资源（哪一个 `HTTP` 响应），这个块的大小是多少。

基于这一点，在 `HTTP2` 实现了 `HTTP1` 中无法实现的「数据资源块交替发送」。

有多种资源块的调度方式:

- 公平多路复用（例如两个渐进的 JPEGs）：`ABABABABAB`
- 加权多路复用（A是B的两倍）：`AABAABAABAAB`
- 反向顺序调度（例如B是密钥服务器推送的资源）：`BBBBAAAA`
- 部分调度（流A被中止且未完整发送）：`AABBBB`

具体使用那种调度方式是 HTTP2 的优先级系统所决定的。

在 `HTTP2` 中，通过这种方式解决了 `HTTP` 的对头堵塞。

#### TCP队头堵塞

`HTTP` 工作在应用层，`HTTP` 的报文被拆分成块之后要经过传输层(`HTTPS` 还需要经过 `TLS` 层的支持)，资源块在传输层还要被封装上 `TCP` 的元数据。


