## 二叉树的遍历

**内容主要来自[labuladong的算法小抄]，感谢东哥**

#### 二叉树遍历基本框架

```typescript
var traverse = function (root) {
  if (root == null) return;
  // 前序位置
  traverse(root.left);
  // 中序位置
  traverse(root.right);
  // 后序位置
}
```

这个框架本质上就是一个能够遍历二叉树的函数，与遍历数组、链表性质一样的，只是因为二叉树的结构不同，表现形式不一致。

```typescript
var traverse = function (arr: number[]) {
  for (let i = 0; i < arr.length; i++) {

  }
}
const arr = [1, 2, 3, 4, 5], res1 = [], res2 = [];
var traverse = function (arr: number[], index = 0) {
  if (index === arr.length) return;

  // 前序位置
  res1.push(arr[index])
  traverse(arr, index + 1);
  // 后序位置
  res2.push(arr[index])
}

// res1: [1,2,3,4,5]
// res2: [5,4,3,2,1]
```

这个思路让人耳目一新，数组还可以这样遍历。借助堆栈，完成了数组的倒序遍历（性能肯定比如for循环，但是为我们提供了另外一种思路）,这里可以发现一个结论：**前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的**。

#### 利用好前序遍历和后序遍历

前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点。每个节点都有「唯一」属于自己的前中后序位置。

- 前序位置的代码在刚刚进入一个二叉树节点的时候执行；
- 后序位置的代码在将要离开一个二叉树节点的时候执行；
- 中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

> 二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。

对前序遍历后序遍历进一步理解可以发现：**前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。

```typescript
// 如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？
var traverse = function (root, level) {
  if (root == null) return 0;
  console.log(`节点${root.val}在第${level}层`);
  traverse(root.left, level + 1);
  traverse(root.right, level + 1);
}

// 如何打印出每个节点的左右子树各有多少节点？

var count = function (root) {
  if (root == null) return 0;
  let leftCount = count(root.left);
  let rightCount = count(root.right);
  console.log(`节点${root.val}左子树有${leftCount}个节点，右子树有${rightCount}个节点`);
  return leftCount + rightCount + 1;
}
```

这两个问题的根本区别在于：一个节点在第几层，你从根节点遍历过来的过程就能顺带记录；而以一个节点为根的整棵子树有多少个节点，你需要遍历完子树之后才能数清楚。

只有后序位置才能通过返回值获取子树的信息。

### 二叉树的直径

[二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

```typescript
var diameterOfBinaryTree = function (root) {
  let max = 0;
  var maxDepth = function (root) {
    if (root == null) return 0;
    let leftDepth = maxDepth(root.left);
    let rightDepth = maxDepth(root.right);

    console.log(leftDepth, rightDepth)
    max = Math.max(leftDepth + rightDepth, max);
    return Math.max(leftDepth, rightDepth) + 1;
  }
  maxDepth(root);
  return max;
};
```

### 226、翻转二叉树(Easy)

[翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/submissions/)

两种方式，在递归的过程中，前序和后序都是可以做交换操作的。中序不行。

自顶向下，将当前节点的左右子节点交换。

```typescript
var invertTree = function (root) {
  if (root == null) return null;

  let temp = root.left
  root.left = root.right;
  root.right = temp;

  invertTree(root.left);
  invertTree(root.right);

  return root;
}
```

自下而上。

```typescript
var invertTree = function (root) {
  if (root == null) return null;

  let left = invertTree(root.left);
  let right = invertTree(root.right);

  root.left = right;
  root.right = left;

  return root;
}
```

### 116、填充每个节点的下一个右侧节点指针

[填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/submissions/)

```typescript
var connect = function (root) {
  if (root == null) return null;
  const queue = [root];
  while (queue.length) {
    let size = queue.length, prev = null;
    while (size > 0) {
      let node = queue.shift();
      if (prev == null) {
        prev = node
      } else {
        prev.next = node;
        prev = node
      }
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
      size--;
    }
    prev.next = null;
  }
  return root;
}
```

换个思路，递归能不能做？递归的难点在于，左节点的右节点（5）不太好跟右节点的左节点（6）产生关系，但是在操作左右节点的时候，可以拿到这两个节点。
我们可以把这两个节点认为是虚拟的中节点，这棵二叉树抽象成三叉树，就像图中的蓝色区域。

![](https://lantiany-1254329693.cos.ap-chongqing.myqcloud.com/blog/20220610115328.png)

```typescript
var connect = function (root) {
  if (root == null) return null;
  traverse(root.left, root.right);
  return root;
}

var traverse = function (left, right) {
  if (left == null || right == null) return;
  
  left.next = right;
  
  traverse(left.left, left.right);
  traverse(right.left, right.right);
  
  traverse(left.right, right.left);
}
```
